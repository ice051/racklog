<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>1&nbsp;简单的目标和查询</title><link rel="stylesheet" type="text/css" href="../scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="../racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../doc-site.css" title="default"/><script type="text/javascript" src="../scribble-common.js"></script><script type="text/javascript" src="../manual-racket.js"></script><script type="text/javascript" src="../manual-racket.js"></script><script type="text/javascript" src="../doc-site.js"></script><script type="text/javascript" src="../local-redirect/local-redirect.js"></script><script type="text/javascript" src="../local-redirect/local-user-redirect.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="doc-racket-lang-org">
<div class="maincolumn"><div class="main">
<h3 x-source-module="(lib &quot;racklog/racklog.scrbl&quot;)" x-source-pkg="racklog" x-part-tag="&quot;simple&quot;">1<tt>&nbsp;</tt><a name="(part._simple)"></a>简单的目标和查询</h3>
<p>Racklog 对象与 Racket 对象相同。但是，Racklog 对这些对象中的两个子集特别感兴趣： <span class="emph">目标</span> 和 <span class="emph">谓词</span> 。我们先来看看一些简单的目标。<a href="predicates.html" data-pltdoc="x">谓词</a> 引入谓词和使用谓词制作复杂目标的方法。</p>
<p>目标是一个我们可以检验其真实性或虚假性的对象。一个被证明是正确的目标就是成功的目标。一个被证明是错误的目标被认为是失败的。</p>
<p><div class="SIntrapara">在 Racklog 中提供两个简单的目标：</div><div class="SIntrapara"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym"><a href="glossary.html#%28def._%28%28lib._racklog%2Fmain..rkt%29._~25true%29%29" class="RktValLink" data-pltdoc="x">%true</a></span></td></tr><tr><td><span class="RktSym"><a href="glossary.html#%28def._%28%28lib._racklog%2Fmain..rkt%29._~25fail%29%29" class="RktValLink" data-pltdoc="x">%fail</a></span></td></tr></table></blockquote></div></p>
<p>目标 <span class="RktSym"><a href="glossary.html#%28def._%28%28lib._racklog%2Fmain..rkt%29._~25true%29%29" class="RktValLink" data-pltdoc="x">%true</a></span> 表示成功。目标 <span class="RktSym"><a href="glossary.html#%28def._%28%28lib._racklog%2Fmain..rkt%29._~25fail%29%29" class="RktValLink" data-pltdoc="x">%fail</a></span> 总是失败。</p>
<p>(所有 Racklog 基本对象的名称都以 <span class="RktInBG"><span class="hspace"></span><span class="RktIn">%</span><span class="hspace"></span></span> 开头。这是为了避免与相关意义的传统 Racket 对象的名称冲突。在 Racklog，用户创建的对象不需要遵循这个约定。)</p>
<p>Racklog 用户可以通过将目标包装为 <span class="RktSym"><a href="glossary.html#%28form._%28%28lib._racklog%2Fmain..rkt%29._~25which%29%29" class="RktStxLink" data-pltdoc="x">%which</a></span> 形式来 <span class="emph">查询</span> 目标。</p>
<blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#%28form._%28%28lib._racklog%2Fmain..rkt%29._~25which%29%29" class="RktStxLink" data-pltdoc="x">%which</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="glossary.html#%28def._%28%28lib._racklog%2Fmain..rkt%29._~25true%29%29" class="RktValLink" data-pltdoc="x">%true</a></span><span class="RktPn">)</span></p></blockquote>
<p>计算结果为 <span class="RktRes">()</span> ，表示成功，而：</p>
<blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#%28form._%28%28lib._racklog%2Fmain..rkt%29._~25which%29%29" class="RktStxLink" data-pltdoc="x">%which</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="glossary.html#%28def._%28%28lib._racklog%2Fmain..rkt%29._~25fail%29%29" class="RktValLink" data-pltdoc="x">%fail</a></span><span class="RktPn">)</span></p></blockquote>
<p>计算结果为 <span class="RktVal">#f</span> ，表示失败。</p>
<p>注 1： <span class="RktSym"><a href="glossary.html#%28form._%28%28lib._racklog%2Fmain..rkt%29._~25which%29%29" class="RktStxLink" data-pltdoc="x">%which</a></span> 形式的第二个子表达式是空列表 <span class="RktRes">()</span> 。稍后(<a href="predicates.html#%28part._solving-goals%29" data-pltdoc="x">求解目标</a>)，我们将看到 <span class="RktSym"><a href="glossary.html#%28form._%28%28lib._racklog%2Fmain..rkt%29._~25which%29%29" class="RktStxLink" data-pltdoc="x">%which</a></span> 与其他列表作为第二个子形式。</p>
<p>今后，我们使用以下符号：</p>
<blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktSym">E</span></td></tr><tr><td><p><span class="RktRes">'F</span></p></td></tr></table></blockquote>
<p> <span class="RktSym">E</span> <span class="emph"> 等于 </span> <span class="RktSym">F</span> 。因此，</p>
<blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#%28form._%28%28lib._racklog%2Fmain..rkt%29._~25which%29%29" class="RktStxLink" data-pltdoc="x">%which</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="glossary.html#%28def._%28%28lib._racklog%2Fmain..rkt%29._~25true%29%29" class="RktValLink" data-pltdoc="x">%true</a></span><span class="RktPn">)</span></td></tr><tr><td><p><span class="RktRes">'()</span></p></td></tr></table></blockquote>
</div></div><div id="contextindicator">&nbsp;</div></body></html>