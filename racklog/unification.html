<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>5&nbsp;统一</title><link rel="stylesheet" type="text/css" href="../scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="../racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../doc-site.css" title="default"/><script type="text/javascript" src="../scribble-common.js"></script><script type="text/javascript" src="../manual-racket.js"></script><script type="text/javascript" src="../manual-racket.js"></script><script type="text/javascript" src="../doc-site.js"></script><script type="text/javascript" src="../local-redirect/local-redirect.js"></script><script type="text/javascript" src="../local-redirect/local-user-redirect.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="doc-racket-lang-org"><div class="maincolumn"><div class="main">
<h3 x-source-module="(lib &quot;racklog/racklog.scrbl&quot;)" x-source-pkg="racklog" x-part-tag="&quot;unification&quot;">5<tt>&nbsp;</tt><a name="(part._unification)"></a>统一</h3>
<p>当我们说目标与子句头匹配时，我们的意思是谓词和实参的位置是一致的。在进行比较之前，Racklog会对所有已经绑定的逻辑变量进行解引用。然后比较得到的结构，看看它们是否递归地相同。因此， <span class="RktVal">1</span> 与 <span class="RktVal">1</span> 相结合， <span class="RktPn">(</span><span class="RktSym"><a href="https://download.racket-lang.org/releases/8.0/doc/local-redirect/index.html?doc=reference&amp;rel=pairs.html%23%2528def._%2528%2528quote._%7E23%7E25kernel%2529._list%2529%2529&amp;version=8.0" class="RktValLink Sq" data-pltdoc="x">list</a></span><span class="stt"> </span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktPn">)</span> 与 <span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktVal">)</span> 相结合；但是 <span class="RktVal">1</span> 和
<span class="RktVal">2</span> 不能统一， <span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">2</span><span class="RktVal">)</span> 和 <span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">1</span><span class="stt"> </span><span class="RktVal">3</span><span class="RktVal">)</span> 也不能统一。</p>
<p>通常，比较对象中可能有相当多的未实例化的逻辑变量。然后，统一将努力找到绑定这些变量的最自然的方法，以便我们得到结构相同的对象。因此， <span class="RktPn">(</span><span class="RktSym"><a href="https://download.racket-lang.org/releases/8.0/doc/local-redirect/index.html?doc=reference&amp;rel=pairs.html%23%2528def._%2528%2528quote._%7E23%7E25kernel%2529._list%2529%2529&amp;version=8.0" class="RktValLink Sq" data-pltdoc="x">list</a></span><span class="stt"> </span><span class="RktVar">x</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktPn">)</span> ，其中 <span class="RktVar">x</span> 是一个未绑定的逻辑变量，与 <span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">0</span><span class="stt"> </span><span class="RktVal">1</span><span class="RktVal">)</span> ，结合，生成绑定 <span class="RktPn">[</span><span class="RktVar">x</span><span class="stt"> </span><span class="RktVal">0</span><span class="RktPn">]</span> 。</p>
<p>因此，统一是一个目标，Racklog 将统一谓词作为 <span class="RktSym"><a href="glossary.html#%28def._%28%28lib._racklog%2Fmain..rkt%29._~25~3d%29%29" class="RktValLink" data-pltdoc="x">%=</a></span> 提供给用户。例如，</p>
<blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#%28form._%28%28lib._racklog%2Fmain..rkt%29._~25which%29%29" class="RktStxLink" data-pltdoc="x">%which</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">x</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#%28def._%28%28lib._racklog%2Fmain..rkt%29._~25~3d%29%29" class="RktValLink" data-pltdoc="x">%=</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym"><a href="https://download.racket-lang.org/releases/8.0/doc/local-redirect/index.html?doc=reference&amp;rel=pairs.html%23%2528def._%2528%2528quote._%7E23%7E25kernel%2529._list%2529%2529&amp;version=8.0" class="RktValLink Sq" data-pltdoc="x">list</a></span><span class="hspace">&nbsp;</span><span class="RktSym">x</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktPn">)</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">(</span><span class="RktVal">0</span><span class="hspace">&nbsp;</span><span class="RktVal">1</span><span class="RktVal">)</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">'((x . 0))</span></p></td></tr></table></blockquote>
<p>Racklog还提供谓词 <span class="RktSym"><a href="glossary.html#%28def._%28%28lib._racklog%2Fmain..rkt%29._~25%2F~3d%29%29" class="RktValLink" data-pltdoc="x">%/=</a></span> ，即 <span class="RktSym"><a href="glossary.html#%28def._%28%28lib._racklog%2Fmain..rkt%29._~25~3d%29%29" class="RktValLink" data-pltdoc="x">%=</a></span> 的 <span class="emph">否定</span> 。 <span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#%28def._%28%28lib._racklog%2Fmain..rkt%29._~25%2F~3d%29%29" class="RktValLink" data-pltdoc="x">%/=</a></span><span class="stt"> </span><span class="RktVar">X</span><span class="stt"> </span><span class="RktVar">Y</span><span class="RktPn">)</span> 当且仅当 <span class="RktVar">X</span> <span class="emph">不</span> 与 <span class="RktVar">Y</span> 统一时成功。</p>
<p>统一目标是所有Racklog目标都遵循的基本子目标。目标之所以成功，是因为至少在其子目标分支中，它分解为的所有最终统一子目标都得到了成功。之所以失败，是因为关键的统一子目标的失败阻碍了所有可能的子目标分支。</p>
<p>回到 <a href="backtracking.html" data-pltdoc="x">回溯</a> 中的例子，目标 <span class="RktPn">(</span><span class="RktSym">%computer-literate</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">Penelope</span><span class="RktPn">)</span> 成功，因为 (a) 和 <span class="RktPn">(</span><span class="RktSym">%computer-literate</span><span class="stt"> </span><span class="RktSym">person</span><span class="RktPn">)</span> 统一；然后， (b) 与 <span class="RktPn">[</span><span class="RktSym">person</span><span class="stt"> </span><span class="RktPn">. </span><span class="RktSym">Penelope</span><span class="RktPn">]</span> 结合， <span class="RktPn">(</span><span class="RktSym">%knows</span><span class="stt"> </span><span class="RktSym">person</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">TeX</span><span class="RktPn">)</span> 与 <span class="RktPn">(</span><span class="RktSym">%knows</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">Penelope</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">TeX</span><span class="RktPn">)</span> 结合，<span class="RktPn">(</span><span class="RktSym">%knows</span><span class="stt"> </span><span class="RktSym">person</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">Prolog</span><span class="RktPn">)</span> 与 <span class="RktPn">(</span><span class="RktSym">%knows</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">Penelope</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">Prolog</span><span class="RktPn">)</span> 结合。</p>
<p>相反，目标 <span class="RktPn">(</span><span class="RktSym">%computer-literate</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">Telemachus</span><span class="RktPn">)</span> 失败，因为 <span class="RktPn">[</span><span class="RktSym">person</span><span class="stt"> </span><span class="RktPn">. </span><span class="RktSym">Telemachus</span><span class="RktPn">]</span> 的子目标 <span class="RktPn">(</span><span class="RktSym">%knows</span><span class="stt"> </span><span class="RktSym">person</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">Racket</span><span class="RktPn">)</span> 和 <span class="RktPn">(</span><span class="RktSym">%knows</span><span class="stt"> </span><span class="RktSym">person</span><span class="stt"> </span><span class="RktVal">'</span><span class="RktVal">Prolog</span><span class="RktPn">)</span> 没有他们可以统一的事实。</p>
<h4 x-source-module="(lib &quot;racklog/racklog.scrbl&quot;)" x-source-pkg="racklog" x-part-tag="&quot;The_Occurs_Check&quot;">5.1<tt>&nbsp;</tt><a name="(part._.The_.Occurs_.Check)"></a>发生检查</h4>
<p>一个鲁棒的统一算法使用 <a name="(tech._occurs._check)"></a><span style="font-style: italic">occurs 检查</span> ，它确保一个逻辑变量不会绑定到包含它自己的结构上。在某些情况下，不执行检查可能导致统一进入无限循环。另一方面，执行occurs检查大大增加统一所花费的时间，即使在不需要检查的情况下也是如此。</p>
<p>Racklog使用全局参数 <span class="RktSym"><a href="glossary.html#%28def._%28%28lib._racklog%2Fmain..rkt%29._use-occurs-check~3f%29%29" class="RktValLink" data-pltdoc="x">use-occurs-check?</a></span> 决定是否使用occurs检查。默认情况下，这个变量是 <span class="RktVal">#f</span> ，也就是说，Racklog禁用发生检查。要启用该检查，</p>
<blockquote class="SCodeFlow"><p><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#%28def._%28%28lib._racklog%2Fmain..rkt%29._use-occurs-check~3f%29%29" class="RktValLink" data-pltdoc="x">use-occurs-check?</a></span><span class="hspace">&nbsp;</span><span class="RktVal">#t</span><span class="RktPn">)</span></p></blockquote>
</div></div><div id="contextindicator">&nbsp;</div></body></html>