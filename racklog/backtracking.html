<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>4&nbsp;回溯</title><link rel="stylesheet" type="text/css" href="../scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="../racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="../doc-site.css" title="default"/><script type="text/javascript" src="../scribble-common.js"></script><script type="text/javascript" src="../manual-racket.js"></script><script type="text/javascript" src="../manual-racket.js"></script><script type="text/javascript" src="../doc-site.js"></script><script type="text/javascript" src="../local-redirect/local-redirect.js"></script><script type="text/javascript" src="../local-redirect/local-user-redirect.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="doc-racket-lang-org"><div class="maincolumn"><div class="main">
<h3 x-source-module="(lib &quot;racklog/racklog.scrbl&quot;)" x-source-pkg="racklog" x-part-tag="&quot;backtracking&quot;">4<tt>&nbsp;</tt><a name="(part._backtracking)"></a>回溯</h3>
<p>稍微详细地讨论下面的计算 (<a href="predicates.html#%28part._rules%29" data-pltdoc="x">带规则的谓词</a>)是很有帮助的：</p>
<blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#%28form._%28%28lib._racklog%2Fmain..rkt%29._~25which%29%29" class="RktStxLink" data-pltdoc="x">%which</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">%computer-literate</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">Penelope</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></blockquote>
<p>开始的目标是：</p>
<blockquote class="SCodeFlow"><p><span class="RktSym">G0</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://download.racket-lang.org/releases/8.0/doc/local-redirect/index.html?doc=reference&amp;rel=generic-numbers.html%23%2528def._%2528%2528quote._%7E23%7E25kernel%2529._%7E3d%2529%2529&amp;version=8.0" class="RktValLink Sq" data-pltdoc="x">=</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">%computer-literate</span><span class="hspace">&nbsp;</span><span class="RktSym">Penelope</span><span class="RktPn">)</span></p></blockquote>
<p>(我把这句话删掉了，因为 <span class="RktRes">Penelope</span> 是对 <span class="RktVal">'</span><span class="RktVal">Penelope</span> 进行评估的结果。)</p>
<p>Racklog试图将其与 <span class="RktSym">%computer-literate</span> 的第一个子句的头匹配。它成功地生成一个绑定 <span class="RktPn">[</span><span class="RktSym">person</span><span class="stt"> </span><span class="RktPn">. </span><span class="RktSym">Penelope</span><span class="RktPn">]</span>。</p>
<p>但这意味着它现在有两个新目标 &#8212;<wbr></wbr> <span class="emph">子目标</span> &#8212;<wbr></wbr> 需要解决。这些是匹配子句的主体中的目标，逻辑变量被它们的实例化替换：</p>
<blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">G1</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://download.racket-lang.org/releases/8.0/doc/local-redirect/index.html?doc=reference&amp;rel=generic-numbers.html%23%2528def._%2528%2528quote._%7E23%7E25kernel%2529._%7E3d%2529%2529&amp;version=8.0" class="RktValLink Sq" data-pltdoc="x">=</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">%knows</span><span class="hspace">&nbsp;</span><span class="RktSym">Penelope</span><span class="hspace">&nbsp;</span><span class="RktSym">TeX</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktSym">G2</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://download.racket-lang.org/releases/8.0/doc/local-redirect/index.html?doc=reference&amp;rel=generic-numbers.html%23%2528def._%2528%2528quote._%7E23%7E25kernel%2529._%7E3d%2529%2529&amp;version=8.0" class="RktValLink Sq" data-pltdoc="x">=</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">%knows</span><span class="hspace">&nbsp;</span><span class="RktSym">Penelope</span><span class="hspace">&nbsp;</span><span class="RktSym">Racket</span><span class="RktPn">)</span></td></tr></table></blockquote>
<p>对于 <span class="RktInBG"><span class="hspace"></span><span class="RktIn">G1</span><span class="hspace"></span></span> ，Racklog 尝试匹配 <span class="RktSym">%knows</span> 的子句，并在第五次尝试时成功。(在这种情况下，没有子目标，因为这些“事实”条款的主体是空的，这与 <span class="RktSym">%computer-literate</span> 中的“规则”子句相反。)然后，Racklog试图根据 <span class="RktSym">%knows</span> 的子句来解决 <span class="RktInBG"><span class="hspace"></span><span class="RktIn">G2</span><span class="hspace"></span></span> ，由于没有子句说明Penelope知道Racket，它失败。</p>
<p>然而并非一切都失败，现在 Racklog <span class="emph">回溯</span> 到之前解决的目标，也就是 <span class="RktInBG"><span class="hspace"></span><span class="RktIn">G1</span><span class="hspace"></span></span> 。它 <span class="emph">重试</span> <span class="RktInBG"><span class="hspace"></span><span class="RktIn">G1</span><span class="hspace"></span></span> ，也就是说，尝试用不同的方式解决它。这需要搜索以前没有考虑到的 <span class="RktInBG"><span class="hspace"></span><span class="RktIn">G1</span><span class="hspace"></span></span> 的 <span class="RktSym">%knows</span> 子句，即第六个子句。显然，Racklog再次失败，因为Penelope知道TeX的事实只发生过一次。</p>
<p>Racklog现在会回溯到 <span class="RktInBG"><span class="hspace"></span><span class="RktIn">G1</span><span class="hspace"></span></span> ，也就是 <span class="RktInBG"><span class="hspace"></span><span class="RktIn">G0</span><span class="hspace"></span></span> 之前的目标。放弃与 <span class="RktSym">%computer-literate</span> 的第一个子句头的当前成功匹配，并尝试下一个子句头。Racklog成功了，再次生成一个绑定的 <span class="RktPn">[</span><span class="RktSym">person</span><span class="stt"> </span><span class="RktPn">. </span><span class="RktSym">Penelope</span><span class="RktPn">]</span> ，以及两个新的子目标：</p>
<blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktSym">G3</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://download.racket-lang.org/releases/8.0/doc/local-redirect/index.html?doc=reference&amp;rel=generic-numbers.html%23%2528def._%2528%2528quote._%7E23%7E25kernel%2529._%7E3d%2529%2529&amp;version=8.0" class="RktValLink Sq" data-pltdoc="x">=</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">%knows</span><span class="hspace">&nbsp;</span><span class="RktSym">Penelope</span><span class="hspace">&nbsp;</span><span class="RktSym">TeX</span><span class="RktPn">)</span></td></tr><tr><td><span class="RktSym">G4</span><span class="hspace">&nbsp;</span><span class="RktSym"><a href="https://download.racket-lang.org/releases/8.0/doc/local-redirect/index.html?doc=reference&amp;rel=generic-numbers.html%23%2528def._%2528%2528quote._%7E23%7E25kernel%2529._%7E3d%2529%2529&amp;version=8.0" class="RktValLink Sq" data-pltdoc="x">=</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktSym">%knows</span><span class="hspace">&nbsp;</span><span class="RktSym">Penelope</span><span class="hspace">&nbsp;</span><span class="RktSym">Prolog</span><span class="RktPn">)</span></td></tr></table></blockquote>
<p>现在很容易追踪到，Racklog发现 <span class="RktInBG"><span class="hspace"></span><span class="RktIn">G3</span><span class="hspace"></span></span> 和 <span class="RktInBG"><span class="hspace"></span><span class="RktIn">G4</span><span class="hspace"></span></span> 都为真。由于 <span class="RktInBG"><span class="hspace"></span><span class="RktIn">G0</span><span class="hspace"></span></span> 的两个子目标都为真， <span class="RktInBG"><span class="hspace"></span><span class="RktIn">G0</span><span class="hspace"></span></span> 本身也被认为是真。这是 Racklog 的报告。感兴趣的读者现在可以追踪为什么下面的查询有一个不同的结局:</p>
<blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="stt">&gt; </span><span class="RktPn">(</span><span class="RktSym"><a href="glossary.html#%28form._%28%28lib._racklog%2Fmain..rkt%29._~25which%29%29" class="RktStxLink" data-pltdoc="x">%which</a></span><span class="hspace">&nbsp;</span><span class="RktPn">(</span><span class="RktPn">)</span></td></tr><tr><td><span class="hspace">&nbsp;&nbsp;</span><span class="hspace">&nbsp;&nbsp;</span><span class="RktPn">(</span><span class="RktSym">%computer-literate</span><span class="hspace">&nbsp;</span><span class="RktVal">'</span><span class="RktVal">Telemachus</span><span class="RktPn">)</span><span class="RktPn">)</span></td></tr></table></td></tr><tr><td><p><span class="RktRes">#f</span></p></td></tr></table></blockquote>
</div></div><div id="contextindicator">&nbsp;</div></body></html>